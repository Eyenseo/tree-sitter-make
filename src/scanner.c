/* Generated by re2c 2.1.1 on Thu May 13 13:46:10 2021 */
#line 1 "src/scanner.re"
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <tree_sitter/parser.h>

#define YYCTYPE int32_t

#define BUFFER_SIZE (4*1024)

#define EAT_LEADING_WHITESPACE(lexer) \
    while (isspace(lexer->lookahead)) \
        lexer->advance(lexer,true)

enum TokenType {
  VAR_NAME,
  RECIPEPREFIX_DEF,
};

typedef struct {
    int cursor;
    int irq;
} Scanner_t;

static
bool scanner_has_action(Scanner_t *scanner) {
    return (scanner->irq != 0);
}

static
bool scanner_var_name_handler(
    Scanner_t *scanner,
    TSLexer *lexer,
    const bool *valid_symbols)
{
    assert(valid_symbols[VAR_NAME]);

    for (int i=0; i<scanner->cursor; i++) {
        lexer->advance(lexer, false);
    }

    scanner->irq ^= (1 << VAR_NAME);
    scanner->cursor = 0;

    lexer->result_symbol = VAR_NAME;
    return true;

}

static
bool scanner_do_action(
    Scanner_t *scanner,
    TSLexer *lexer,
    const bool *valid_symbols)
{
    assert(!isspace(lexer->lookahead));

    if (scanner->cursor && (1 << VAR_NAME))
        return scanner_var_name_handler(scanner, lexer, valid_symbols);

}


// Fill a buffer calling lexer->lookahead multiple times until "=" (inclusive).
// Lines splits (\\\n) are replaced with whitespaces.
// If end of file or newline is found, return -1
static
int fill_buffer(TSLexer * lexer, YYCTYPE * buffer)
{
    int n = 0;

    assert (isascii(lexer->lookahead) && "EAT_LEADING_WHITESPACE shall be called before fill_buffer");
    assert (!isspace(lexer->lookahead));

loop:
    assert (n < BUFFER_SIZE);

#line 81 "src/scanner.c"
    {
        YYCTYPE yych;
        yych = lexer->lookahead;
        switch (yych) {
        case 0x00:
        case '#':    goto yy2;
        case '\n':    goto yy6;
        case '=':    goto yy8;
        default:    goto yy4;
        }
yy2:
        buffer[n++] = lexer->lookahead; lexer->advance(lexer, false);
#line 120 "src/scanner.re"
        { goto reject; }
#line 96 "src/scanner.c"
yy4:
        buffer[n++] = lexer->lookahead; lexer->advance(lexer, false);
#line 122 "src/scanner.re"
        { goto loop; }
#line 101 "src/scanner.c"
yy6:
        buffer[n++] = lexer->lookahead; lexer->advance(lexer, false);
#line 97 "src/scanner.re"
        {
            assert(buffer[n-1] == '\n');

            if (n >= 3 && buffer[n-3] == '\\' && buffer[n-2] == '\r') {
                buffer[n-3] = ' ';
                buffer[n-2] = ' ';
                buffer[n-1] = ' ';

                goto loop;
            }

            if (n >= 2 && buffer[n-2] == '\\') {
                buffer[n-2] = ' ';
                buffer[n-1] = ' ';

                goto loop;
            }

            goto reject;
        }
#line 125 "src/scanner.c"
yy8:
        buffer[n++] = lexer->lookahead; lexer->advance(lexer, false);
#line 118 "src/scanner.re"
        { goto accept; }
#line 130 "src/scanner.c"
    }
#line 123 "src/scanner.re"


assert(false && "missing goto in the lexer rules");

accept:
    buffer[n] = '\0';
    return n;

reject:
    for (int i=0; i<n; i++)
        buffer[i] = '\0';

    return -1;
}

// assume the buffer does line split
static
int lex_variable(const YYCTYPE *YYCURSOR)
{

    const YYCTYPE *YYMARKER_START = YYCURSOR;
    const YYCTYPE *YYMARKER, *YYCTXMARKER;


#line 157 "src/scanner.c"
    {
        YYCTYPE yych;
        yych = *YYCURSOR;
        switch (yych) {
        case 0x00:
        case '\t':
        case ' ':
        case ':':
        case '=':    goto yy12;
        default:    goto yy14;
        }
yy12:
        ++YYCURSOR;
yy13:
#line 166 "src/scanner.re"
        { return -1; }
#line 174 "src/scanner.c"
yy14:
        yych = *(YYMARKER = ++YYCURSOR);
        if (yych <= 0x00) goto yy13;
        goto yy16;
yy15:
        yych = *++YYCURSOR;
yy16:
        switch (yych) {
        case 0x00:    goto yy17;
        case '\t':
        case ' ':
            YYCTXMARKER = YYCURSOR;
            goto yy18;
        case '!':    goto yy20;
        case '+':    goto yy22;
        case ':':    goto yy24;
        case '=':    goto yy25;
        case '?':    goto yy27;
        default:    goto yy15;
        }
yy17:
        YYCURSOR = YYMARKER;
        goto yy13;
yy18:
        yych = *++YYCURSOR;
        switch (yych) {
        case '\t':
        case ' ':    goto yy18;
        case '!':
        case '+':
        case '?':    goto yy29;
        case ':':    goto yy30;
        case '=':    goto yy31;
        default:    goto yy17;
        }
yy20:
        yych = *++YYCURSOR;
        switch (yych) {
        case 0x00:    goto yy17;
        case '\t':
        case ' ':
            YYCTXMARKER = YYCURSOR;
            goto yy18;
        case '!':    goto yy20;
        case '+':    goto yy22;
        case ':':    goto yy24;
        case '=':    goto yy33;
        case '?':    goto yy27;
        default:    goto yy15;
        }
yy22:
        yych = *++YYCURSOR;
        switch (yych) {
        case 0x00:    goto yy17;
        case '\t':
        case ' ':
            YYCTXMARKER = YYCURSOR;
            goto yy18;
        case '!':    goto yy20;
        case '+':    goto yy22;
        case ':':    goto yy24;
        case '=':    goto yy35;
        case '?':    goto yy27;
        default:    goto yy15;
        }
yy24:
        yych = *++YYCURSOR;
        switch (yych) {
        case ':':    goto yy37;
        case '=':    goto yy38;
        default:    goto yy17;
        }
yy25:
        ++YYCURSOR;
        YYCURSOR -= 1;
#line 164 "src/scanner.re"
        { return YYCURSOR-YYMARKER_START; }
#line 252 "src/scanner.c"
yy27:
        yych = *++YYCURSOR;
        switch (yych) {
        case 0x00:    goto yy17;
        case '\t':
        case ' ':
            YYCTXMARKER = YYCURSOR;
            goto yy18;
        case '!':    goto yy20;
        case '+':    goto yy22;
        case ':':    goto yy24;
        case '=':    goto yy40;
        case '?':    goto yy27;
        default:    goto yy15;
        }
yy29:
        yych = *++YYCURSOR;
        switch (yych) {
        case '=':    goto yy31;
        default:    goto yy17;
        }
yy30:
        yych = *++YYCURSOR;
        switch (yych) {
        case ':':    goto yy29;
        case '=':    goto yy31;
        default:    goto yy17;
        }
yy31:
        ++YYCURSOR;
        YYCURSOR = YYCTXMARKER;
#line 157 "src/scanner.re"
        { return YYCURSOR-YYMARKER_START; }
#line 286 "src/scanner.c"
yy33:
        ++YYCURSOR;
        YYCURSOR -= 2;
#line 162 "src/scanner.re"
        { return YYCURSOR-YYMARKER_START; }
#line 292 "src/scanner.c"
yy35:
        ++YYCURSOR;
        YYCURSOR -= 2;
#line 163 "src/scanner.re"
        { return YYCURSOR-YYMARKER_START; }
#line 298 "src/scanner.c"
yy37:
        yych = *++YYCURSOR;
        switch (yych) {
        case '=':    goto yy42;
        default:    goto yy17;
        }
yy38:
        ++YYCURSOR;
        YYCURSOR -= 2;
#line 160 "src/scanner.re"
        { return YYCURSOR-YYMARKER_START; }
#line 310 "src/scanner.c"
yy40:
        ++YYCURSOR;
        YYCURSOR -= 2;
#line 161 "src/scanner.re"
        { return YYCURSOR-YYMARKER_START; }
#line 316 "src/scanner.c"
yy42:
        ++YYCURSOR;
        YYCURSOR -= 3;
#line 159 "src/scanner.re"
        { return YYCURSOR-YYMARKER_START; }
#line 322 "src/scanner.c"
    }
#line 168 "src/scanner.re"

}

static
bool scan_variable_name(TSLexer* lexer, Scanner_t *scanner)
{
    YYCTYPE buffer[BUFFER_SIZE];
    int len = 0;

    assert(!isspace(lexer->lookahead));

    lexer->mark_end(lexer);

    len = fill_buffer(lexer, buffer);

    if (len <= 1)
        return false;

    len = lex_variable(buffer);

    if (len < 1)
        return false;

    scanner->irq |= (1 << VAR_NAME);
    scanner->cursor = len;

    lexer->result_symbol = VAR_NAME;
    return true;

}

bool tree_sitter_make_external_scanner_scan(
        void *payload,
        TSLexer *lexer,
        const bool *valid_symbols) {

    Scanner_t * scanner = payload;
    const YYCTYPE * cur;

    if (scanner_has_action(scanner))
        return scanner_do_action(scanner, lexer, valid_symbols);

    EAT_LEADING_WHITESPACE(lexer);

    if (valid_symbols[VAR_NAME])
        return scan_variable_name(lexer, scanner);

    return false;

}

void *tree_sitter_make_external_scanner_create() {
    Scanner_t *scanner = calloc(1,sizeof(Scanner_t));
    assert(scanner);

    assert(!(scanner->cursor));
    assert(!(scanner->irq));
    //scanner->recipeprefix = (YYCTYPE) '>';

    return scanner;
}

void tree_sitter_make_external_scanner_destroy(void *payload) {
    free(payload);
}

unsigned tree_sitter_make_external_scanner_serialize(
    void *payload,
    char *buffer) {

    memcpy(&payload, &buffer, sizeof(Scanner_t));

    //printf("serialize (%ld,%x)\n\n",
    //        ((Scanner_t*) payload)->cursor,
    //        ((Scanner_t*) payload)->irq);

    return sizeof(Scanner_t);
}

void tree_sitter_make_external_scanner_deserialize(
    void *payload,
    const char *buffer,
    unsigned length) {

    memcpy(&buffer, payload, sizeof(Scanner_t));

    //printf("deserialize (%ld,%x)\n\n",
    //        ((Scanner_t*) payload)->cursor,
    //        ((Scanner_t*) payload)->irq);

}
